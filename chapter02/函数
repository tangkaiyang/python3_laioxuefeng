函数

抽象

调用函数
abs:绝对值函数
交互式命令行help(abs)查看abs函数的帮助信息
传入函数参数数量不对:TypeError
传入参数的类型不能接受:TypeError
max:可接受多个参数,返回最大值

数据类型转换
int()可以把其他数据类型转换为整数:
函数同样是一个对象,可以赋值给变量

定义函数
注意,函数体内部的语句在执行时,一旦执行到return时,函数就执行完毕,并将结果返回.
如果没有return语句,函数执行完毕后也会返回结果,只是结果为None.return None可以简写为return
空函数
pass:可以作为占位符

参数检查
调用函数时,如果参数个数不对,Python解释器就会自动检查出来,并抛出TypeError
但是如果参数类型不对,Python解释器就无法帮我们检查.
自定义函数需要自行做参数检查
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('bas operand type')
    if x >= 0:
        return x
    else:
        return -x

返回多个值
返回值是一个tuple,在语法上,返回一个tuple可以省略括号

小结:
定义函数时,需要确定函数名和参数个数;
如果有必要,可以先对参数的数据类型做检查;
函数体内部可以用return随时返回函数结果;
函数执行完毕也没用return语句时,自动return None
函数可以同时返回多个值,其实就是一个tuple

函数的参数
除了正常的必选参数,还可以使用默认参数,可变参数和关键字参数
位置参数:
def power(x, n): -> power(5, 2) -> x, n都是未知参数,传入的两个值按照未知顺序依次赋值给x和n
默认参数:
def power(x, n=2): ->power(5) -> n为默认参数,有默认值2
                  ->power(5, 3) -> 重新为n赋值3
默认参数注意:
一是必选参数在前,默认参数在后,否则Python的解释器会报错
二是如何设置默认参数.
当函数有多个参数时,把变化大的参数放前面,变化小的参数放后面.变化小的参数就可以作为默认参数.默认参数可以降低调用函数的难度
默认参数必须指向不变对象

可变参数
def calc(*numbers): -> calc(1, 2, 4, .....)
定义可变参数和定义一个list或tuple参数相比,在参数前面加了一个*号,参数numbers接收到的是一个tuple
python允许再list或tuple前加一个*号,把list或tuple的元素编程可变参数传进去
nums = [1, 2, 3] -> calc(*nums) -> calc(1, 2, 3)

关键字参数
可变参数允许你传入0个或任意个参数,这些可变参数在函数调用时会自动组装成一个tuple.而关键字参数允许你传入0个或任意个含参数名的参数,这些关键字参数在函数内部会自动组装成一个dict
def person(name, age, **kw)
    print('name': name, 'age': age, 'other': kw)
函数person除了必选参数name和age外,还接受关键字参数kw.在调用该函数时,可以只传入必选参数:
person('Michael', 30) -> name: Michael age: 30 other: {}
也可以传入任意个数的关键字参数:
person('Bob', 35, city='Beijing') -> name: Bob age: 35 other: {'city': 'Beijing'}
person('Adam', 45, gender="M", job="Engineer") -> name: Adam age: 45 other: {'gender': "M", 'job': "Enigneer"}
关键字参数可以拓展函数的功能,比如,在person函数里,我们保证能接受到name和age这两个参数,但是,如果调用者愿意提供更多的参数,我们
也能收到.试想你正在做一个用户注册的功能,除了用户名和年龄是必填以外,其他都是可选项,利用关键字参数来定义这个函数就能满足注册
的需求
和可变参数类似,也可以先组装出一个dict,然后 把dict转换为关键字参数传进去:
extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra) -> name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
**extra表示把extra这个dict的所有key-value用关键字参数传入都函数的**kw参数,kw将获得一个dict,注意kw获得的dict是extra的一份拷贝,对kw的改动不会影响到函数外的extra

命名关键字参数
对于关键字参数,函数的调用者可以传入任意不受限制的关键字参数.至于到底传入了哪些,就需要在函数内部通过kw检查
仍以person()函数为例,我们希望检查是否有city和job参数:
def person(name, age, **kw):
    if 'city' in kw:
        # 有city参数
        pass
    if 'job' in kw:
        # 有job参数
        pass
但是调用者仍可以传入不受限制的关键字参数:
如果要限制关键字参数的名字,就可以用命名关键字参数,例如,只接受city和job作为关键字参数.
def person(name, age, *, city, job):
    print(name, age, city, job)
和关键字参数**kw不同,命名关键字参数需要一个特殊分隔符*, *后面的参数被视为命名关键字参数.
调用方式:person('Jack', 24, city='Beijing', job='Engineer')
如果函数定义中已经有一个可变参数,后面跟着的命名关键字参数,就不再需要一个特殊分隔符*了:
def person(name, age, *args, city, job):
命名关键字参数必须传入参数名,这和位置参数不同,如果没有传入参数名,调用将报错
由于调用时缺少参数名,解释器把这4个参数均视为位置参数,但函数只接受2个位置参数
命名关键字参数可以由缺省值,从而简化调用:
def person(name, age, *, city="Beijing", job):
使用命名关键字参数时,要特别注意,如果没有可变参数,就必须加一个*作为特殊分隔符,如果缺少*,Python解释器将无法识别位置参数和命名关键字参数


参数组合
必选参数,默认参数,可变参数,关键字参数和命名关键字参数可以组合使用
注意:参数定义的顺序必须为:必选参数,默认参数,可变参数,命名关键字参数和关键字参数
对应任意函数,都可以通过类似func(*args, **kw)的形式调用它,无论它的参数是如何定义的.

小结:
Python的函数具有非常灵活的参数形态,既可以实现简单的调用,又可以传入非常复杂的参数
默认参数一定要用不可变对象,如果是可变对象,程序运行时会有逻辑错误!
要注意定义可变参数和关键字参数的语法:
*args是可变参数,args接受的是一个tuple
**kw是关键字参数,kw接受的是一个dict
以及调用函数时如何传入可变参数和关键字参数的语法:
可变参数既可以直接传入:func(1, 2, 3),又可以先组装list或tuple,再通过*args传入:func(*(1, 2, 3))
关键字参数既可以直接传入:fun(a=1, b=2),又可以先组装dict,再通过**kw传入:func(**{'a': 1, 'b': 2})
使用*args和**kw是Python的习惯写法,当然也可以用其他参数名,但最好使用习惯用法.
命名的关键字参数是为了限制调用者可以传入的参数名,同时可以提供默认值.
定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*,否则定义的将是位置参数

递归函数
在函数内部,可以调用其他函数.如果一个函数在内部调用自身本身,这个函数就是递归函数.
使用递归函数需要注意防止栈溢出.在计算机中,函数调用是通过栈(stack)这种数据结构实现的,每当进入一个函数调用,栈就会加一层栈帧,
每当函数返回,栈就会减一层栈帧.由于栈的大小不是无限的,所以,递归调用的次数过多,就会导致栈溢出
def fact(n):
    if n == 1:
        return 1
    return n * fact(n-1)
解决递归调用栈溢出的方法是通过尾递归优化,事实上尾递归和循环的效果是一样的,所以,把循环看成是一种特殊的尾递归函数也是可以的.
尾递归是指,在函数返回的时候,调用自身本身,并且,return语句不能包含表达式.这样,编译器或解释器就可以把尾递归做优化,使递归本身
无论调用多少次,都只占用一个栈帧,不会出现栈溢出的情况
def fact(n):
    return fact_iter(n, 1)
def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num -1, num * product)
上述仅返回递归函数本身,num-1和num*product在函数调用前就会被就计算,不影响函数调用
尾递归调用时,如果做了优化,栈不会增长,因此无论多少次调用也不会导致栈溢出
遗憾的是,大多数编程语言没有针对尾递归做优化,python解释器也没用做优化,所以,即使把上面的fact(n)函数改成尾递归方式,也会导致栈溢出

小结
使用递归函数的优点是逻辑简单清晰,缺点是过深的调用会导致栈溢出
针对尾递归优化的语言可以通过尾递归防止栈溢出.尾递归事实上和循环是等价的,没有循环语句的编程语言只能通过尾递归实现循环.
Python标准的解释器没有针对尾递归做优化,任何递归函数都存在栈溢出的问题
