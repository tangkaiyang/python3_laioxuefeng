正则表达式
正则表达式是一种匹配字符串的强有力的武器.它的设计思想是用一种描述性的语言来给字符串定义一个规则,凡是
符合规则的字符串,我们就认为它"匹配"了,否则,该字符串就是不合法的

直接给出字符串,精确匹配
\d匹配一个数字
\w匹配一个字母或数字
.匹配任意字符
*表示任意个字符(包括0个)
+表示至少一个字符
?表示0个或一个字符
{n}表示n个字符
{n,m}表示n-m个字符
\s匹配一个空格(也包括Tab等空白符)
\对特殊字符进行转义

进阶
[]表示范围,如:
[0-9a-zA-Z\_]可以匹配一个数字,字母或下划线;
A|B匹配A或B,(P|p)ython匹配'Python'或'python'
^表示行的开头,^\d表示必须以数字开头
$表示行的结束,\d$表示必须以数字结束
py也可以匹配'python',但是^py$只能匹配'py'


re模块
注意Python的字符串本身也用\转义
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成:
# 'ABC\-001'
建议使用r前缀,就不需要考虑转义
import re
re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
match()方法判断是否匹配,如果匹配成功,返回一个Match对象,否则返回None

切分字符串
用正则表达式切分字符串比用固定的字符更灵活
'a b    c'.split(' ') --> ['a', 'b', '', '', 'c']
 'a b   c'.split(' ')
 无法识别连续的空格,
 re.split(r'\s+', 'a b  c') --> ['a', 'b', 'c']
 re.split(r'[\s\,]+', 'a,b,c  d') --> ['a', 'b', 'c', 'd']

# 列表的sort与sorted方法类似,sort在原列表上操作,sorted返回新的列表对象

分组
除了简单的判断是否匹配之外,正则表达式还有提取子串的强大功能.用()表示的就是要提取的分组(Group)
^(\d{3})-(\d{3,8})$分别定义了两个组,可以直接从匹配的字符串中提取区号和本地号码:
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345') --> 返回match对象
m.group(0)-->'010-12345'
m.group(1)-->'010'
m.group(2)-->'12345'
如果正则表达式中定义了组,就可以在Match对象上用group()方法提取子串出来
group(0)永远是原始字符串
提取时分秒:
t = '19:05:30'
m = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:([0-5]?[0-9])\:([0-5]?[0-9])$', t)
m.groups()

贪婪匹配
需要特别指出,正则匹配默认是贪婪匹配,也就是匹配尽可能多的字符.
例:匹配出数字后面的0:
re.match(r'^(\d+)(0*)$', '1023000').groups() --> ('1023000', '')
由于\d+采用贪婪匹配,直接把后面的0全部匹配了,结果0*只能匹配空字符串了
必须让\d+采用非贪婪匹配(也就是尽可能少匹配),才能把后面的0匹配出来,加?可以让\d+采用非贪婪匹配
re.match(r'^(\d+?)(0*)$', '1023000').groups() --> ('1023', '000')

编译
Python中使用正则表达式,re模块内部会干两件事
1.编译正则表达式,如果正则表达式的字符串本身不合法,会报错;
2.用编译后的正则表达式去匹配字符串
如果一个正则表达式要重复使用几千次,出于效率的考虑,我们可以预编译该正则表达式,接下来重复使用就不需要
编译这个步骤了,直接匹配:
import re
# 编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用
re_telephone.match('010-12345').groups() --> ('010', '12345')
te_telephone.match('010-8086').groups() --> ('010', '8086')
编译后生成Regular Expression对象,由于该对象自己包含了正则表达式,所以调用对应的方法时不用给出正则字符串

小结:
正则表达式非常强大,要在短短的一节里讲完是不可能的.要讲清楚正则的所有内容,可以写一本厚厚的书了.
如果你经常遇到正则表达式的问题,可能需要一本正则表达式的参考书

