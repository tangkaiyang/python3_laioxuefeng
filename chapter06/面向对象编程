面向对象编程
面向对象编程--Object Oriented Programming,简称OOP,是一种程序设计思想.OOP把对象作为程序的基本单元,一个对象包含了数据和操作数据的函数
面向过程的程序设计把计算机程序视为一系列的命令集合,即一组函数的顺序执行.为了简化程序设计,面向过程把函数继续切分为子函数,即把大块函数通过切割成小块函数来降低系统的复杂度
而面向对象的程序设计把计算机程序视为一组对象的集合,而每个对象都可以接收其他对象发过来的消息,并处理这些消息,计算机程序的执行就是一系列消息在各个对象之间传递
在Python中,所有数据类型都可以视为对象,当然也可以自定义对象.自定义的对象数据类型就是面向对象中的类(Class)的概念

类和实例
Class和Instance
有了__init__方法,在创建实例的时候,就不能传入空的参数了,必须传入与__init__方法匹配的参数,

数据封装

小结:
类是创建实例的模板,而实例则是一个一个具体的对象,各个实例拥有的数据都相互独立,互不影响;
方法就是与实例绑定的函数,和普通函数不同,方法可以直接访问实例的数据;
通过在实例上调用方法,我们就直接操作了对象内部的数据,但无需知道方法内部的实现细节.
和静态语言不同,Python允许对实例变量绑定任何数据,也就是说,对应两个实例变量,虽然他们都是同一个类的不同实例,但拥有的变量名称都可能不同

访问限制
让内部属性不被外部访问,可以把属性的名称前加上两个下划线__,在Python中,实例的变量名如果以__开头,就变成了一个私有变量(private),只有内部可以访问,外部不能访问
这样就确保了外部代码不能随意修改对象内部的状态,这样通过访问限制的保护,代码更加健壮

双下划线开头的实例变量,不能直接访问,因为Python解释器对外把__name变量改成了_Student__name,仍然可以通过_Student__name来访问__name变量
避免class.__property = ..的写法


继承和多态
在OOP程序设计中,当我们定义一个class的时候,可以从某个现有的class继承,新的class称为子类(Subclass),而被继承的class称为基类,父类或超类(Base class,Super class)

当我们定义了一个class的时候,我们实际就定义了一种数据类型
判断一个变量是否是某个类型可以用isinstance()判断

动态语言的鸭子类型:它并不要求严格的继承体系,一个对象只要"看起来像鸭子,走起路来像鸭子",那它就可以被看做是鸭子(python基于协议)

小结:
继承可以把父类的所有功能都直接拿过来,这样就不必从零做起,子类只需要新增自己特有的方法,也可以把父类不适合的方法覆盖重写
动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的


获取对象信息
type()判断对象类型(isinstance推荐)
使用isinstance()对于class 的继承关系来说,使用type()就很不方便

i总是优先使用isinstance()判断类型,可以将制定类型及其子类"一网打尽"

使用dir():获取一个对象的所有属性和方法,返回一个包含字符串的list

类似__xx__的属性和方法在Python中都有特殊用途的,比如__len__方法返回长度.在Python中,如果你调用len()函数试图获取一个对象的长度,实际上,在len()函数内部,它自动去调用该对象的__len__()方法
len('ABC') <==> 'ABC'.__len__()
配合getattr(),setattr()以及hasattr(),我们可以直接操作一个对象的状态

小结
通过内置的一系列函数,我们可以任意对一个Python对象进行剖析,拿到其内部的数据.要注意的是,只有在不知道对象信息的时候,我们才会去
获取对象信息.如果可以直接写:
sum = obj.x + obj.y
就不要写:
sum = getattr(obj, 'x') + getattr(obj, 'y')
一个正确的用法的例子如下:
def readImage(fp):
    if hasattr(fp, 'read'):
        return readData(fp)
    return None
假设我们希望从文件流fp中读取图像,我们首先要判断fp对象是否存在read方法,如果存在,则该对象是一个流,如果不存在,则无法读取.hasattr()就派上用场了
请注意,在Python这类动态语言中,根据鸭子类型,有read()方法,不代表fp对象就是一个文件流,它也可以是网络流,也可能是内存中的一个字节流,但只要read()方法返回的是有效的图像数据,就不影响读取图像的功能

实例属性和类属性
由于Python是动态语言,根据类创建的实例可以任意绑定属性.
给实例绑定属性的方法是通过实例变量,或者通过self变量:
但是,如果Student类本身需要绑定一个属性,可以直接在class中定义属性,这种属性是类属性
class Student():
    def __init__(self, name):
        self.name = name # 实例属性
    name = 'Student' # 类属性
当我们定义了一个类属性后,这个属性虽然归类所有,但类的所有实例都可以访问到
在编写程序的时候,千万不要对实例属性和类属性使用相同的名字,因为相同名称的实例属性将屏蔽掉类属性,但是当你删除实例属性后,再使用相同的名称,访问到的将是类属性

小结
实例属性属于各个实例所有,互不干扰
类属性属于类所有,所有实例共享一个属性
不要对实例属性和类属性使用相同的名字,否则将产生难以发现的错误