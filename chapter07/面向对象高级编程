面向对象高级编程
数据封装,继承和多态只是面向对象程序设计中最基础的三个概念.在Python中,面向对象还有很多高级特性,允许我们写出非常强大的功能
多重继承,定制类,元类等概念

使用__slots__
from types import MethodType --> s.set_age= MethodType(set_age, s) # 给实例绑定一个方法,对另外的实例不起作用
Student.set_score = set_score # 给class绑定方法,所有实例均可调用
通常情况下,上面的set_score方法可以直接定义在class中,但动态绑定允许我们在程序运行的过程中动态给class加上功能,静态语言难以实现

使用__slots__
限制实例的属性,比如只允许对Student实例添加name和age属性
定义class时-->__slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称
s.score = 99 --> AttributeError --> 由于score没有被放到__slots__中,所以不能绑定
注意:__slots__定义的属性仅对当前类实例起作用,对继承的子类是不起作用的,除非子类也定义了__slots__,这样子类实例允许定义的属性就是自身的__slots__加上父类的__slots__

使用@property
在绑定属性时,如果我们直接把属性暴露除去,虽然写起来很简单,但是,没办法检查参数,导致可以把成绩随便改
s = Student() -> s.score = 9999
这显然不合逻辑.为了限制score的范围,可以通过一个set_score()方法来设置成绩,再通过一个get_score()来获取成绩,这样,在set_score()方法里,就可以检查参数
class Student():
    def get_score(self):
        return self._score
    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError("score must be integer!")
        if value < 0 or value > 100:
            raise ValueError("score must between 0~100!")
        self._score = value
但是,上面的调用方法略显复杂,没有直接用属性这么直接简单
内置的@property装饰器就是负责把一个方法变为属性调用的
class Student():
    @property
    def score(self):
        return self._score
    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            ......
@property把一个getter方法编程属性,此时@property本身又创建了另一个装饰器@score.setter,负责把一个setter方法变成属性赋值,于是我们就拥有了一个可控的属性操作
定义只读属性,指定义getter方法,不定义setter方法就是一个只读属性

小结:
@property广泛应用在类的定义中,可以让调用者写出简短的代码,同时保证对参数进行必要的检查,这样,程序运行时就减少了出错的可能性

