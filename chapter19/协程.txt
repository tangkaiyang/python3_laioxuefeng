协程
协程,又称微线程,纤程,英文名coroutine
子程序,或者称为函数,在所有语言中都是层级调用,比如A调用B,B在执行过程中又调用了C,C执行完毕返回,B执行完毕返回,最后是A执行完毕
所以子程序调用是通过栈实现的,一个线程就是执行一个子程序.
子程序调用总是一个入口,一次返回,调用顺序是明确的.
而协程的调用和子程序不同.
协程看上去也是子程序,但执行过程中,在子程序内部可中断,然后转而执行别的子程序,在适当的时候再返回来接着执行.
注意,在一个子程序中中断,去执行其他子程序,不是函数调用,有点类似CPU的中断
协程的特点:一个线程执行
与多线程相比,协程极高的执行效率.
因为子程序切换不是线程切换,而是由程序自身控制制,
因此,没有线程切换的开销,和多线程比,线程数量越多,协程的性能优势就越明显.
第二大优势就是不需要多线程的锁机制,因为只有一个线程,也不存在同时写变量冲突,在协程中控制共享资源不加锁,只需要判断状态就好了,所以执行效率比多线程高很多.
因为协程是一个线程执行,那怎么利用多核CPU呢?
最简单的方法是多进程+协程,既充分利用了多核,又充分发挥协程的高效率,可获得极高性能.
Python对协程的支持是通过generator实现的.
在generator中,我们不但可以通过fro循环来迭代,还可以不断调用next()函数获取由yield语句返回的下一个值.
但是Python的yield不但可以返回一个值,它还可以接受调用者发出的参数.
例如:
传统的生产者-消费者模型是一个线程写消息,一个线程取消息,通过锁机制控制队列和等待,一不小心就可能死锁.
如果改用协程,生产者生产消息后,直接通过yield跳转到消费者开始执行,待消费者执行完毕后,切换回生产者继续生产,效率极高.
coroutine_test.py
用Task封装两个coroutine
coroutine_test.py
两个coroutine是由用一个线程并发执行的.
如果把asyncio.sleep()换成真正的IO操作,则多个coroutine就可以由一个线程并发执行.
用asyncio的异步网络连接来获取sina,sohu和163的网站首页
web_connect_test.py

小结
asyncio提供了完善的异步IO支持;
异步操作需要在coroutine中通过yield from完成;
多个coroutine可以封装成一组Task然后并发执行

async/await
用asyncio提供的@asyncio.coroutine可以把一个generator标记为coroutine类型,然后在coroutine内部用yield from调用另一个coroutine实现异步操作

Python3.5引入新语法async和await
1.@asyncio.coroutine --> async
2.yield from --> await
