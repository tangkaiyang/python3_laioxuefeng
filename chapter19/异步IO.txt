异步IO

CPU速度远远快于磁盘网络等IO
在一个线程中,CPU执行代码的速度极快,然而,一旦遇到IO操作,如读写文件,发送网络数据时,就需要等待IO操作完成,才能继续进行下一步操作.
这种情况称为同步IO.
在IO操作的过程中,当前线程被挂起,而其他需要CPU执行的代码就无法被当前线程执行了.
因为一个IO操作就阻塞了当前线程,导致其他代码无法执行,
所以我们必须使用多线程或多进程来执行代码,为多个用户服务.
每个用户都会分配一个线程,如果遇到IO导致线程被挂起,其他用户的线程不受影响.
多线程和多进程的模型虽然解决了并发问题,但是系统不能无上限地增加线程.
由于系统切换线程的开销也很大,所以,一旦线程数量过多,CPU的时间就花在线程切换上了,真正运行代码的时间就少了,结果导致性能下降严重.
由于我们要解决的问题是CPU高速执行能力和IO设备的龟速严重不匹配,
多线程和多进程只是解决这一问题的一种方法.
另一种解决IO问题的方法是异步IO.
当代码需要执行一个耗时的IO操作时,他只发出IO指令,并不等待IO结果,然后就去执行其他代码了.
一段时间后,当IO返回结果时,再通知CPU进行处理.
同步IO模型的代码是无法实现异步IO模型的.
异步IO模型需要一个消息循环,在消息循环中,主线程不断重复"读取消息-处理消息"这一过程:
loop = get_event_loop()
while True:
    event = loop.get_event()
    process_event(event)
