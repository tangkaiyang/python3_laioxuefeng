函数式编程
函数式python内建支持的一种封装,我们通过把大段代码拆成函数,通过一层一层的函数调用,就可以把复杂任务分解成简单的任务,这种分解
可以称之为面向过程的程序设计.函数就是面向过程的程序设计的基本单元.
而函数式编程--FUnctional Programming,虽然也可以归结到面向过程的程序设计,但其思想更接近数学计算
计算机(Computer)与计算(Compute)概念
在计算机层次上,CPU执行的是加减乘除的指令代码,以及各种条件判断和跳转指令,所以,汇编语言是最贴近计算机的语言.
而计算则是指数学意义上的计算,越是抽象的计算,离计算机硬件越远
对应到编程语言,就是越低级的语言,越贴近计算机,抽象程度低,执行效率高,比如C语言;越高级的语言,越贴近计算,抽象程度高,执行效率低,比如Lisp
函数式编程就是一种抽象程度很高的编程范式,纯粹的函数式编程语言编写的函数没有变量,因此,任意一个函数,只要输入是确定的,输出就是确定的,
这种纯函数我们称之为没有副作用.而允许使用变量的程序设计语言,由于函数内部的变量状态不确定,同样的输入,可能得到不同的输出,因此,这种函数是有副作用的
函数式编程的一个特点就是,允许把函数本身作为参数传入另一个函数,还允许返回一个函数
python对函数式编程提供部分支持.由于python允许提供变量,因此python不是纯函数式编程语言

高阶函数
高阶函数Higher-order function
变量可以指向函数:python中一切皆对象
abs() -> f = abs -> f(-10) -> 10
函数名也是变量

传入函数
函数接收另一个函数为参数,这种函数就称之为高阶函数
def add(a, y, f):return f(x) + f(y)
小结:
把函数作为参数传入,这样的函数称为高阶函数,函数式编程就是这种高度抽象的编程范式

map/reduce
Python内建了map()和reduce()函数
map(f, Iterable) -> f(iter),f(iter).....
map()函数接收两个参数,一个是函数,另一个是Iterable,map将出传入的函数一次作用到序列的每个元素,并把结果作为新的Iterator返回
f(x) = x * x , map(f, [1, 2, 3, 4]) -> list(map(f, [1, 2, 3, 4])) -> [1, 4, 9, 16]
所有数字转化为字符串:
list(map(str, [1, 2, 3, 4, 5, 6])) -> ['1', '2', '3', '4', '5', '6']


reduce
reduce把一个函数作用在一个序列上,这个函数必须接收两个参数,reduce把结果继续和序列的下一个元素做累积计算
reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
from functools import reduce
def add(x, y):
    return x + y
reduce(add, [1, 3, 5, 7, 9]) -> ((((1+3)+5)+7)+9) -> 25
[1, 3, 5, 8, 9]转化为十进制数 -> reduce(f, [1, 3, 5, 8, 9]), f(x, y):x*10 + y -> 13589
str也是一个序列,配合map(),把str转换成int的函数

filter
filter()函数用于过滤序列
和map()类似,filter()也接收一个函数和一个序列.和map()不同的是,filter()把传入的函数依次作用于每个元素,然后根据返回值是
True还是False决定保留还是丢弃该元素
删掉偶数,只保留奇数
def is_odd(n):return n % 2 == 1 -> list(filter(is_odd, [1, 2, 3, 4, 5])) -> [1, 3, 5]
删掉序列中的空字符串:
def not_empty(s):return s and s.strip() -> list(filter(not_empty, ['A', 'B', "  ", None, 'C', ' '])) -> ['A', 'B', 'C']
filter()关键在于正确实现了一个"筛选"函数,filter()函数返回的是一个Iterator,也就是一个惰性序列,所以要强迫filter()完成计算结果
,需要用到list()函数获得所以结果并返回list

小结:
filter()的作用是从一个序列中筛选出符号条件的元素.由于filter()使用了惰性计算,所以只有在取filter()结果的时候,才会真正筛选并
每次返回下一个筛出的元素

sorted
排序算法
sorted([36, 5, -12, 9, -21]) -> [-21, -12, 5, 9, 36]
sorted()函数也是一个高阶函数,它还可以接收一个key函数来实现自定义的排序
按绝对值排序:sorted([36, 5, -12, 9, -21], key=abs) -> [5, 9, -12, -21, 36]
key指定的函数将作用在list的每一个元素上,并根据key函数返回的结果进行排序
默认情况下,对字符串的排序,是按照ASCII的大小比较的,先大写后小写
忽略大小写排序(都转换为大写或小写):
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower) -> ['about', 'bob', 'Credit', 'Zoo']
反向排序,不必改动key函数,可以传入第三参数reverse=True
sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) -> ['Zoo', 'Credit', 'bob', 'about']
高阶函数的抽象能力是非常强大的,而且,核心代码可以保持得非常简洁
小结:
sorted()也是一个高阶函数,用sorted()排序的关键在于实现一个映射函数

返回函数

函数作为返回值
高阶函数除了可以接受函数作为参数外,还可以把函数作为结果值返回
可变参数的求和
如果不需要立即求和,而是在后面的代码中,根据需要计算,可以不返回求和的结果,而是返回求和的函数
def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
当调用lazy_sum()时,返回一个求和函数
调用返回的函数f()时,才真正计算求和结果
上述例子中,我们在函数lazy_sum中又定义了函数sum,并且,内部函数sum可以引用外部函数lazy_sum的参数和局部变量,当lazy_sum返回函数
sum时,相关参数和变量都保存在返回的函数中,这种称为"闭包"(Closure)的程序结构拥有极大的威力
当我们调用lazy_sum()时,每次调用都会返回一个新的函数对象,即使传入相同的参数

闭包
注意到返回的函数在其定义内部引用了局部变量args,所以,当一个函数返回一个函数后,其内部的局部变量还被新函数引用,所以,闭包,用起来简单
,实现起来可不容易
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i * i
        fs.append(f)
    return fs
f1, f2, f3 = count()
此时f1(),f2(),f3()返回值均为9,
因为返回的函数引用了变量i,但它并非立刻执行.等到3个函数都返回时,i=3
注意:返回闭包要牢记一点:返回函数不要引用任何循环变量,或者后续会发生变化的变量
如果一定要引用循环变量,方法是创建一个函数,用该函数的参数绑定循环变量当前的值:
def count():
    def f(j):
        def g():
            return j * j
        return g
    fs = []
    for i in range(1, 4)
        fs.append(f(i))
    return fs
这里循环变量i会传入固定的j
缺点就是代码较长,可以用lambda函数缩短代码

小结:
一个函数可以返回一个计算结果,也可以返回一个函数
返回一个函数时,牢记该函数并未执行,返回函数中不要引用任何可能会变化的变量